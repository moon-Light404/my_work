## 图算法

最短路径Dijkstra算法:

- 假设顶点是$V_0到V_5$ 六个点，开始时候是没有连线的，但是已知能互相到达的顶点之间的边权。
- 步骤是每次从顶点0开始查找，找出==距离顶点最短的点==，然后标记该点为true,再查询该点能直达的其他点加上边权会不会比原先记录的距离值小--->即更新最短距离；遍历完了所有从该点能到的点后再次回到起点。

```c++
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXV=1000;
const int INF = 1000000000;//很大的数九位0

int n,m,s,G[MAXV][MAXV];//n为顶点数量，m为边数，s为起点
int d[MAXV];//起点到各点的最短路径长度
bool vis[MAXV]={false}; //标记访问数组 false为没有访问，true 为访问过
/*本题输入:
6 8 0 //6个顶点  8条边  起点为0号
0 1 1 从0点到1点距离为1
0 3 4
0 4 4
1 3 2
2 5 1
3 2 2
3 4 3
4 5 3
*/
void Dijkstra(int s){
    fill(d,d+MAXV,INF); 
    d[s]=0; //初始化操作
    for(int i=0;i<n;i++){//每次更新完都要回到起点,循环n次
        int u=-1,MIN=INF; //比较下面，u使得d[u]最小，MIN存放该最小的d[u]
        for(int j=0;j<n;j++){
            if(vis[j]==false && d[j]<MIN){
                u = j;
                MIN = d[j];
            }
        }
        if(u=-1) return;//剩下的顶点和起点s不通
        vis[u]= true;//找出距离起点最短的点 u
        for(int v=0;v<n;v++){//从 u 开始走，更新最短距离
            if(vis[v]==false && G[u][v]!=INF && d[u]+G[u][v]<d[v]){//G[u][v]是从u到v顶点的直通距离
                d[v]=d[u]+G[u][v];
            }
        }
    }
}
int main(){
    int u,v,w;
    cin>>n>>m>>s;
    fill(G[0],G[0]+MAXV*MAXV,INF);
    for(int i=0;i<m;i++){
        cin>>u>>v>>w;
        G[u][v]=w;
    }
    Dijkstra(s);
    for(int i=0;i<n;i++){
        cout<<d[i];//输出结果最短路径
    }
    return 0;
}
```

### 基本模板

```c++
//初始化
for(循环n次){
    u = 使得d[u]最小且还未被访问的顶点的标号;
    记u已被访问;
    for(从u出发能到达的所有顶点v){
        if(v未被访问 && 以u为中介点使s到顶点v 的最短距离d[v]更优){
            优化d[v];
        }
```

### 

