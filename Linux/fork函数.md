### fork后的父子进程

由fork创建的新进程称为子进程。该函数被调用一次，但返回两次。

在==子进程的返回值是0==，==父进程中的返回值是新进程(子进程)的进程id==。

**将子进程id返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程id**。

对子进程来说，之所以fork返回0给它，是因为它随时可以调用`getpid()`来获取自己的`pid`；也可以调用`getppid()`来获取父进程的id。(进程id 0总是由交换进程使用，所以一个子进程的进程id不可能为0 )。

fork之后，**操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置**（两进程的程序计数器`pc`值相同，也就是说，==子进程是从fork返回处开始执行的==)，但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。
可以这样想象，2个进程一直同时运行，而且步调一致，在fork之后，他们分别作不同的工作，也就是分岔了。这也是fork为什么叫fork的原因

至于那一个最先运行，可能与操作系统（调度算法）有关，而且这个问题在实际应用中并不重要，如果需要父子进程协同，可以通过原语的办法解决。

```c
include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
 
int main(void)
{
        pid_t pid=fork();
        if(pid==0)
        {
                int j ;
                for(j=0;j<10;j++)
                {
                        printf("child: %d\n",j);
                        sleep(1);
                }
        }
        else if (pid>0)
        {
                int i;
                for(i=0;i<10;i++)
                {
                        printf("parent: %d\n",i);
                        sleep(1);
                }
        }
        else
        {
                fprintf(stderr,"can't fork ,error %d\n",errno);
                exit(1);
        }
        printf("This is the end !");
}
```

在`linux`系统中执行效果如下：

<img src = 'https://i.bmp.ovh/imgs/2021/05/d8934b5199afdca2.png' />

分析现象：可以看出在父进程`fork`之后，父进程和子进程交替运行，在子进程中`pid=0`执行第一个`if`语句进入for循环，且一直在这里停留，后面被父进程剥夺资源，父进程`pid>0`,执行第二个`if`，进入第二个for循环，就这样来回交替往复运行。