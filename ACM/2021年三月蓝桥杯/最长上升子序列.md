题目：给定一个长度为 NN 的数列，求数值严格单调递增的子序列的长度最长是多少。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n;
int a[N];
int f[N]; // f[i]表示 以第i个数结尾 的数最长的子序列

int main()
{
    cin >> n ;
    for (int i = 1; i <= n; i ++ ) cin >> a[i];

    int res = 0;
    for (int i = 1; i <= n; i ++ )
    {
        f[i] = 1; // 先标记为1
        for (int j = 1; j < i; j ++ )
            if (a[i] > a[j])
                f[i] = max(f[i], f[j] + 1);

        res = max(res, f[i]); // res记录子序列当前可能的最大值
    }

    cout << res << endl;

    return 0;
}
```



从某点向两端做LIS，就是在序列中取一个数 h，从第一个数开始到h是递增的，然后从 h 到尾部是递减的(等价于从两端分别递增到h)



```c++
for(int i = n; i >= 1; i--) // 从尾部遍历
{
    f[i] = 1;
    for(int j = n; j > i; j--) // j在i后面的位置
        if(a[i] > a[j])	f[i] = max(f[j] + 1,f[i]);
}
```



### 最长子序列记录长度

```c++
#include <iostream>

using namespace std;

const int N = 1010;

int n;
int a[N];
int f[N], g[N];

// g[N] 表示从谁转移过来的

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++) cin >> a[i];

    for (int i = 1; i <= n; i ++)
    {
        f[i] = 1;
        g[i] = 0;
        for (int j = 1; j < i; j ++)
            if (a[i] > a[j])
                if (f[i] < f[j] + 1)
                    {
                        f[i] = f[j] + 1;
                        g[i] = j;
                    }
    }

    int k = 1;
    for (int i = 1; i <= n; i ++)
        if (f[i] > f[k]) k = i;
    cout << f[k] << endl;

    for (int i = 0, len = f[k]; i < len; i ++)
    {
        cout << a[k] << ' ';
        k = g[k];
    }
    return 0;
}

```

