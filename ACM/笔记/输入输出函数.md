## 数组邻接表模拟图

- 用数组邻接表模拟无向图

https://www.acwing.com/blog/content/4663/详细分析点此链接

```c++
int h[N] // 下标为结点的编号
int e[M], w[M], nxt[M]; // e,w,nxt数组下标为边的编号
int idx; // idx为边的编号
```



==图片解析==

```c++
const int N = 1010, M = 1010;
int h[N],e[M],ne[M],idx;

void add(int a, int b, int weight) // 起点、终点、权重
{
    e[idx] = b; // 记录终点
    w[idx] = weight; // 记录权重
    nxt[idx] = h[a]; // 与该条边邻接的边(以a为起点的边)的编号
    h[a] = idx; // 以a为起点对应的上一条边的编号,更行h[a],方便下一条边记录数据
    idx++;
    
    /*
     e[eidx] = v;        // 记录边的终点
    w[eidx] = weight;   // 记录边的权重
    nxt[eidx] = h[u];   // 将下一条边指向结点u此时的第一条边
    h[u] = eidx;        // 将结点u的第一条边的编号改为此时的eidx
    eidx++;             // 递增边的编号edix, 为将来使用
    */
}

// 遍历结点u的所有相邻的边
void iterate(int u)
{
    for(int eid = h[u];eid != -1;eid = nxt[eid])
    {
        int v = e[eid];
        int weight = w[eid];
        cout << u << "->" << v << ",weight:" << we
    }
}

int main()
{
    int n, m;
    cin >> n >> m;
    memset(h,-1,sizeof h);
    idx = 0; // 编号从0开始
    
    while(m--)
    {
        int u, v, weight;
        cin >> u >> v >> weight;
        add(u,v,weight);
    }
    
    for(int u = 1; u <= n;u++)
        iterate(u);
    return 0;
}
```

在有向图中， `1->2`和`1->3`表示的才是领边，才会被nxt数组记录；

又如`2->4`和`3->4`之间 2 和 3是不相通的，所以nxt数组值为 -1，表示没有邻接边



- 模拟有向图

如果要模拟无向图那么只要双向的边都看作不同的两条边添加就行了，比如

add(a,b)   and 	add(b,a)即可



  